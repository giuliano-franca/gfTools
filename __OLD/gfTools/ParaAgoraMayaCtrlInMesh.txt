# Create inMesh controllers
import maya.cmds as cmds
# Get faces of mesh to control
mainFaces = cmds.ls(sl=True, fl=True)
# Get the controller to change
ctrl = ""
# Get the object to control
jnt = cmds.ls(sl=True)
# Duplicate mesh selected and attatch control
mainMesh = faces[0].split('.')[0]
newCtrl = cmds.duplicate(mainMesh, rr=True)
# Match pivot to object to control
jntPos = cmds.xform(jnt, q=True, ws=True, rp=True)
cmds.move(jntPos[0], jntPos[1], jntPos[2], newCtrl[0]+".rp", newCtrl[0]+".sp", rpr=True)
# Substitute older ctrl or create new setup
if ctrl == "":
    cmds.parent(jnt, newCtrl[0], r=True)
else: pass
# Manage attrs of new controller
newCtrlShape = cmds.listRelatives(newCtrl[0], s=True)[0]
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlOffset", at="double3")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlOffsetX", at="double", parent="CtrlOffset")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlOffsetY", at="double", parent="CtrlOffset")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlOffsetZ", at="double", parent="CtrlOffset")
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlOffsetX", edit=True, channelBox=True)
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlOffsetY", edit=True, channelBox=True)
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlOffsetZ", edit=True, channelBox=True)
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlScale", at="double3")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlScaleX", at="double", parent="CtrlScale")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlScaleY", at="double", parent="CtrlScale")
cmds.addAttr("|"+newCtrl[0]+"|"+newCtrlShape, ln="CtrlScaleZ", at="double", parent="CtrlScale")
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlScaleX", edit=True, channelBox=True)
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlScaleY", edit=True, channelBox=True)
cmds.setAttr("|"+newCtrl[0]+"|"+newCtrlShape+".CtrlScaleZ", edit=True, channelBox=True)
# Create the warp effect
transGeo = cmds.shadingNode('transformGeometry', asUtility=True)
decompMatrix = cmds.shadingNode('decomposeMatrix', asUtility=True)
compMatrix = cmds.shadingNode('composeMatrix', asUtility=True)
pmaOffsetMult = cmds.shadingNode('plusMinusAverage', asUtility=True)
pmaScaleMult = cmds.shadingNode('plusMinusAverage', asUtility=True)
cmds.connectAttr((mainMesh+".outMesh"), (transGeo+".inputGeometry"))
cmds.connectAttr((newCtrl[0]+".worldInverseMatrix[0]"), (decompMatrix+".inputMatrix"))
cmds.connectAttr((decompMatrix+".outputTranslate"), (pmaOffsetMult+".input3D[0]"))
cmds.connectAttr((newCtrlShape+".CtrlOffset"), (pmaOffsetMult+".input3D[1]"))
cmds.connectAttr((pmaOffsetMult+".output3D"), (compMatrix+".inputTranslate"))
cmds.connectAttr((decompMatrix+".outputRotate"), (compMatrix+".inputRotate"))
cmds.connectAttr((decompMatrix+".outputScale"), (pmaScaleMult+".input3D[0]"))
cmds.connectAttr((newCtrlShape+".CtrlScale"), (pmaScaleMult+".input3D[1]"))
cmds.connectAttr((pmaScaleMult+".output3D"), (compMatrix+".inputScale"))
cmds.connectAttr((decompMatrix+".outputShear"), (compMatrix+".inputShear"))
cmds.connectAttr((compMatrix+".outputMatrix"), (transGeo+".transform"))
cmds.connectAttr((transGeo+".outputGeometry"), (newCtrlShape+".inMesh"))
# Cut off faces of control
faces = []
toDelete = []
for x in range(len(mainFaces)):
    faces.append(mainFaces[x].split('.f')[1].split('[')[1].split(']')[0])
numFaces = cmds.polyEvaluate(newCtrl[0], f=True)
for x in range(0, numFaces):
    if str(x) in faces: print('Face encontrada: .f[%s]'%(x))
    else: toDelete.append(newCtrl[0]+".f["+str(x)+"]")
cmds.select(toDelete, r=True)
cmds.Delete()